---
title: "単純なコマンドの拡張"
---

「よく現れるコード」であれば何でもかんでもコマンド化すればよいという訳では無く, コマンド化した方がよいコードのまとまりも, コマンド化しない方がよいまとまりも両方存在する. 前者の最も重要な例が単純なコマンドである.

この章では, 前者に該当する新しい類型を紹介する. それらは, 対応概念を持つという単純なコマンドの基本要件を尊重しながら, 単純なコマンドをある意味で拡張することで得られる.

## 言葉の定義

単純なコマンドを略して**単コマンド**とも呼ぶことにする.

**合成コマンド**と呼ぶことにする.

- ユーザーが定義したコマンドに依存する形で定義されたコマンド
- 標準記号のみの組み合わせでできており,

## 拡張1: 対応概念を持つ合成コマンド

コマンドの合成の乱用は依存関係を複雑にして, 保守性を下げる場合があるので慎重になるべきということはまず明言しておく. その一方で, 積極的に定義した方がよい"上手い"合成の仕方もある. その典型例が, 単純なコマンド同士の合成が再び対応概念を持つケースである.

たとえば, 接空間の基底の変換則が(Einstein の縮約ルールを使って)以下のように書かれているとする.

$$ \left .\frac{\partial}{\partial x_{i_1}}\right|_{p} = \frac{\partial \widetilde{x}_{j_1}}{\partial x_{i_1}}(p) \left .\frac{\partial}{\partial \widetilde{x}_{j_1}}\right|_{p} $$

そして, 右辺に対応するコードは

```tex
\derivative{\~{x}_{j_1}}{x_{i_1}}(p) \tanBasis{\~{x}_{j_1}}[p]
```

と書かれていたとする. この部分は変換則そのものに対応する

```tex
\tanBasisTrans{from=x_{i_1}, to={\~{x}}, subscr=j_1}[p]
```

のようなコマンドを定義して置き換えると可読性が上がり, 意味も明確になる. その実装は, 既存のコマンドを併記するような内容になるので, 直観的でメンテナンスが楽な内容に収まりやすい.

`\derivative` コマンドに添字オプションを導入するのはあまり自然ではないが, 基底変換となるとかなり自然に思える. 和を表現する方法として添字に渡って動かすことは一般的だからだ. 引数名 `subscr` の代わりに(和を取る添字なので) `over` と名付けてもよいが, テンソル等と関連付けられ得ることを見据えて, 下付き添字であることを明示する `subscr` とした.

:::message
このような形で合成コマンド化できるコードの束を見抜くには, その数式が表す意味内容への理解が欠かせない. これを発見するために精査すべきは, 数式自体であって, その $\LaTeX$ コードではないように思える.
:::

ただし, 可読性の向上などが見込めない状況で合成コマンドを定義するメリットはない. また, このような合成コマンドをさらに合成することも無しではないが, 保守性が犠牲にならないかなど十分な注意を持って判断されるべきだろう.

## 拡張2: 概念操作コマンド

合成型よりもさらに抽象度が高いのが概念操作型である.

あるコードの束が固有名詞としての対応概念を持たなくても, その分野におけるある内在的対象(これは典型的には固有名詞を持つからコマンド化されていることが多い)に対する定型的な操作を行うものであるならば, それは広義の対応概念を持っているようなものだ[^1]. たまたま固有名詞を与えられていないだけで, その分野に内在する操作と見なせるからだ. この場合はコマンド化する利益が大きい場合が多い.

[^1]: コマンドが対応概念を持つことがなぜ重要かを考えてみるとよい. 当該分野における**内在的対象**を対応物に持つことが可読性や保守性に資するからである. その対象が固有名詞を持つかどうかは実は本質ではないのだ.

たとえば,

$$ \int_{\Omega} \left( \frac{\partial u_n}{\partial x_i} v_n + u_n \frac{\partial v_n}{\partial x_i} \right) \varphi $$

という積分を次のようなコードで書いているとして,

```tex
\integral{\left( \derivative{u_n}{x_i} v_n + u_n \derivative{v_n}{x_i} \right) \varphi}[over={\Omega}]
```

このコードの可読性を上げることを考える. `\derivative` 周りの対称性を利用してなんとかする方法も有り得るが, 今はある関数 `(\derivative +...)` を別の関数 `\varphi` と掛け合わせた上で積分するという定型的な操作に注目する. 以下のように, "別の関数と一緒に積分する"という操作を表現するコマンドを定義する.

```tex
\integralWith{f=\derivative{u_n}{x_i} v_n + u_n \derivative{v_n}{x_i}, with=\varphi}[over={\Omega}, bracket=true]
```

`with=` を導入して掛け算の切れ目を明らかにすることで, brackets `()` の挿入を `bracket=` オプションに任せられ, コードの意味が見えやすくなった.

念のため補足しておくと, `bracket=` は積分概念ではなく, 今回取り入れた掛け算に由来して導入されている. 都合が良いから気分で足した訳では無い. 都合が良いように上手に概念を選んだと言って欲しい.

:::message
概念操作型のコマンドは, 合成型よりも見つけるのが難しい. 操作内容に固有名詞を与えられていないことが多いので, そもそも耳で聞いた覚えがないものである場合が多い. コマンド名も自分で発明する必要がある. その一方で, 合成型よりも広く利用できることが多く, 可読性等への貢献は大きい.
合成型と同様にして, コードよりも数式を見た方が見つけやすい. また, 欲しい機能(上の例で言えば`bracket`オプション)から逆算してそれを自然に持つ概念・操作・演算(上の例で言えば積)を考えるという方法もある. コマンド設計作業の中で最も創造的かつ難易度の高い作業であると思う.
:::

このような操作的なコマンドの引数は, key-value形式のような説明的な仕立てにするとよい. 読み上げ的なコマンド引数(順)と相性がよいからだ.

なお, この操作だけなら `\integralWith` コマンドとして独立させなくても `\integral` に `with=` と `bracket=` オプションを足すだけでも悪くない. ここでは, 積分(や微分)コマンドは放っておくと機能が肥大化しやすいことを危惧して, 初めから独立させることを選んだ. どちらが正解かは分からない. 書いている文書やユーザーの好みに依るだろう.
