---
title: "単純なコマンドの条件"
---

$\LaTeX$で数式を書こうとすると, 数式を表現するための最小単位となるコマンド群を整備したくなるのは自然な欲求だろう. この最小単位を構成要素として, より複雑な数式を組み上げていくことを目論むわけだ. 多くの数式関連のパッケージは, この目論見を背景として作られているのだろう.

数式コードに可読性・保守性を求めるならば, 当然, この最小単位となるコマンド自体もまた可読性・保守性の高いものであって欲しいだろう. そのようなコマンドを仮に, 最小単位コマンドと呼ぶことにしよう.

この最小単位の選び方は, 何らかの基準を設定しない限り, おそらく無数にある. 最も自明な選び方は, $\LaTeX$ 標準 + amsmath パッケージ群の記号をそのまま使うことだろう. たとえば, 行列 $A$ の転置 $A ^{\top}$ を出力するために `A^{\top}` と書く選択がそれに該当する.

:::message
$\LaTeX$ 標準記号に加えて, ユーザーが `\usepackage` で導入したパッケージの記号を加えた記号の集合を**標準記号群**と呼ぶことにする. この標準記号群を出力するために用いるコマンド群も標準記号群と(言葉を乱用して)呼ぶ.
:::

本書ではこの自明な方法を直接は採用せず, 次のように微修正する. すなわち, 標準記号群の一部を, 以下の意味で単純なコマンドで置き換えた集合を最小単位コマンドとして使用することを提案する.

- 単純なコマンドの条件
  - 名が体を表すこと
  - 唯一つの対応概念を持つこと
  - 最小限のインターフェースであること
  - 対応概念を持つ他のコマンドの派生コマンドでないこと

小難しい言い方をしたが, 今は「基本は標準記号群を使って, 単純なコマンドが使える場面では単純なコマンドを使うといいぞ!」というシンプルな話だと思って欲しい.

(ちなみに, 後で単純でないが有用なコマンド群も定義するので, この提案は暫定的なものである.)

この意味で単純なコマンドは, 可読性・保守性に優れ, 対応概念を持つという制約下で簡約不可能という意味で最小単位であり, また最小単位コマンドに求められる不変性の要求も満たす. このことを以下で確認する.

## 名が体を表すこと

これは単純なコマンドの条件というより, "まともな"コマンドに要求される条件だ. 当然の条件だが, 非常に重要である. コマンドには読み手がその機能を想像でき, かつ他のコマンドと容易に区別できる示唆的な名前を付けるべきだ. 過度な略称は控えた方がよい. 意味の伝わらない短い名前より, 冗長でウザい名前の方がずっと良い.

たとえば, 写像の値域(range) $\mathcal{R} f$ を意図するコマンドなら `\R f` よりも `\range f` がよい. 長さ$n$の置換群(symmetric group)を意図するコマンドなら `\sg{n}` ではなく, `\symGrp{n}` くらいまで書いた方が読み手に確実に伝わる.

この条件は逆に言えば, 名前から想像できない機能を与えてはいけないことをも暗に要請する. つまり, 名から体を見ても, 体から名を見ても自然であることを要請する. この点は, 別の観点からも重要であることが以下で分かる.

## 唯一つの対応概念を持つこと

ここで言う対応概念とは, コマンドの内容が実質的に表す, 執筆中の文書に登場する概念で, 当該分野における標準的概念などの, その分野の内在的対象と見なすことができる概念を指す. 当面は, その分野で一般的に認められている固有名詞を持つ概念のことだと思ってよい. たとえば, `\newcommand{\transpose}[1]{ #1 ^{\top}}` の対応概念は転置, `\derivative` の対応概念は微分という具合だ. この対応概念の存在は本書で扱うコマンドにおける本質的な条件だ.

言われてみると当たり前と感じるかもしれないが, この基準を破ったばかりに, 扱いづらくなってしまったコマンドを非常によく見かける. 自然な所作であるという理解はされているが, その効用自体があまり理解されていないのだろう.

では, 唯一つの対応概念があると何がよいか.

### 可読性

まず, 対応概念があるコードそれ自体の意味が分かりやすい. たとえば, $\overline{A}$ を $A$ の複素共役行列として,

$$\overline{A}^{\top} = \overline{A^{\top}}$$
のコードをベタにかけば,

```tex:
\overline{A}^{\top} = \overline{A^{\top}}
```

となるが, コードだけ見てその意味は掴みやすいとは言い難いだろう. `\overline` が複素共役記号を指し, `^{\top}` が転置記号を指すことが前提とされ, その上で記号とその意味の通訳作業を介して初めてコードの意味が理解できる. `\overline` はさておき, `\top` のような記号を暗記しておけという要求は, (私のような)忘れっぽい人間に優しくない.

このコードは, `\conjugate=\overline` を複素共役を対応概念に持つコマンドとして定義して,

```tex
\transpose{\conjugate{A}} = \conjugate{\transpose{A}}
```

のように, 通訳結果の意味を直接書いてしまう方が分かりやすい. 心のなかで "transpose of conjugate of A = conjugate of transpose of A" とコードをそのまま読み上げれば意味が分かる.

このような書き方は, 複素共役 → `\overline`, 転置 → `^{\top}` のように

$$概念 \to 記号$$

という対応をコマンド定義に込めることで初めて可能になる. これはコマンドが対応概念を持つということに他ならない.

また, その周辺のコードの意味も理解しやすくなる. 一般に, 読み手はその文書の内容(コードではなくPDF上の内容の方)についての理解を完全ではないものの部分的には持っている. その知識をコードの読解に利用できるようなスタイルでコードを書いておけば, 読み手がコードを読む際のヒントが増え, 読解の負担軽減が期待できる. コマンドに対応概念を持たせることは, そのようなスタイルの実現方法の1つである.

たとえば, `\transpose{A} y` を見たとき, `y` について何の説明もされなくても, `y` は `A` の行数に等しい次元を持つベクトルだと想像がつくだろう.

この読解方法は, そのソースコード特有のルールや属人的な知識を前提としないので, 汎用的に使える方法でもある. 対応概念の候補が複数あると読み手の推測の精度が落ちるので, 対応概念は1つだけがよい.

### 保守性

保守性の観点からは, コマンドが, "文書が扱う概念・話題それ自体"に対して定義され, レイアウトや文章構造, コンテンツの表示方法, 記号の選び方等の目先の要素とは独立になることが挙げられる. 厳密には, コマンドの"出力"は特定の記号の選び方に依存するが,

$$概念→その記号$$

という自然な対応が, コマンド宣言

```tex
\newcommand{\概念}{その記号}
```

によって出来上がるので, 記号管理に関心がある文脈における依存関係としては大変都合が良い. 記号変更の要請の大半を占める概念起点の記号変更に, このコマンドの中身を書き変えるだけで簡単に対処できる.

1つのコマンドに対応する概念が1つだけなら, そのコマンドの中身を変えても変更の影響はその概念に対応する部分だけに収まり, 他所にまで変更の影響が波及することはない. 1つの概念には1つのコマンドだけが対応するなら, なお管理が楽になる.

## 最小限のインターフェースであること

::::details インターフェースとは (プログラミング未経験者向け)
:::message

以下は, 一般的なインターフェースの説明ではありません. この記事の目的に合わせて意味を狭めたり, 強調する点が変更されています.
:::

インターフェースとは, 自分自身の入出力のパターンを宣言・公開し, その動作を保証することを約束したもの. 内部処理の方法には言及せずに, 外界に対して自分がどう振る舞うかだけを約束する.

たとえば, `\mathbb` コマンドを使うとき, ユーザーは入力の引数に対する結果の表示のパターンしか知らない. 内部でどういう実装をしてるかはユーザーは気にしない. アプデ等で内部処理の方法に修正が入ったとしても, 今までと同じ方法で引数を与えて黒板文字の出力を得られることは変わらないはずだとユーザーは信じている. この引数と出力の表示の組がまさに `\mathbb` のインターフェースだ. ユーザーは内部実装の詳細に関わらず不変に提供されるインターフェースを暗に理解していて, 普段から暗に利用している.

このように, 内部処理の詳細をブラックボックスとする代わりに, 入出力の型の不変性を外部に対して保証するのがインターフェースの特徴的役割だ.
::::

この条件は, 単純なコマンドの条件というよりも, 最小単位コマンドが満たすべき条件である.

最小単位コマンドは, その文書内では標準記号群並に広範に使われる基本的な単位になることが期待される. `document` 環境に書かれた最小単位コマンドは, それを書いた日に期待された役割を今日も明日も果たさなければならない. ある日突然, 必須引数の数や並びが変更されるようなことがあってはならない.

であれば, 最小単位コマンドは一度定義された後は, amsmath 等と同様に, **外的に与えられた対象**として扱うのが自然だ. つまり, 最小単位コマンドは, 標準記号群のように, 一般ユーザー対して公開する用のインターフェースを持っており, ユーザーはそれを `\usepacakge{minimal-commands}` を介して使用しているに過ぎないという態度を取るべきだ.

したがって, 最小単位コマンドは,

- コマンド名
- 入力: 並び順も含めた自然な必須引数 + オプション
- 出力: コマンド名が指す表示対象

を今後変更しない前提で定義されなければならない(正確には, 後方互換性を持たせられるならオプションは途中で増やしてもよい). それ以外のコマンド定義の中身はいくらでも変えてよい. 代わりに, 中身の変更の必要が生じてもこれらの外面を維持できるように定義する. たとえば記号の変更が発生したとき, 対応箇所は該当コマンドの中身を修正するだけで済み, `document` 環境のコードに触らなくても済むようにする. **これを守れる見込みのないような最小単位コマンドはそもそも定義してはならない.**

:::message
【補足】
ここで言う「インターフェース」のニュアンスは, 変更前の使用方法を変更後もサポートするという点で後方互換性の概念とも近い. しかし, 個々の具体的な内部処理には興味がなく, サポート対象の固定的な入出力形式にだけ興味があるという点を強調するために, インターフェースという言葉を敢えて使っている.
:::

もちろん, 将来起こる変更を現時点で想定し尽くすことは不可能だ. そんな神業は求めていない. ここで要求していることは, 最小単位コマンドの仕事と仕様はシンプルなものと約束しておき, 難しい変更要求がそのコマンドに降って来たり, 別の2コマンドへ解体される余地がないように, 自身の役割は十分に小さく定義しよう, ということだ. 「最小限(のインターフェース)」が意味するところは, まさにこの点であり, 最小単位コマンドという概念の名が示す通り, 実際の機能も最小であるべきことを指す.

特に強調しておきたいのは, 想定入力のパターンは欲張らず, 最小限に留めるべきことだ. 多様な入力パターンを認めることは, 多機能主義や実装の複雑化, 影響範囲の肥大化などに繋がり, 破綻可能性と破綻時のリスクサイズをいたずらに大きくする.

最小限のインターフェースを持つコマンドは, 余計な引数やオプションを持たないだろうから, 簡素なものになっているはずだ. あとはコマンド名が自然であれば, 読み手が解釈しやすい対象になることが期待できる. このようなコマンドが保守性に優れることは明らかだろう.

## 対応概念を持つ他のコマンドの派生コマンドでないこと

ここは読まなくていいと思う.

単純なコマンドの派生コマンドを, 単純なコマンドから除外するための技術的要求である. なぜ除外したいかと言えば, そのようなコマンドを単純なコマンドに含めると, 最小らしさから離れてしまうからだ.

この条件を認めれば, 単純なコマンドは対応概念を2つ以上持たなくなり, 第2条件「唯一つの対応概念を持つこと」おける「唯一つの」は不要になる.
