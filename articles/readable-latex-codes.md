---
title: "LaTeX コードの可読性・保守性を高めるコマンドデザイン"
emoji: "🙆"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["latex"]
published: false
---

## About

数理系の文書を想定する.
$\LaTeX$ コードの可読性・保守性を上げる方法論で私が使っているものを紹介する.
$\LaTeX$ 上級者から口伝された秘伝の技のような立派なものではなく, 一般ユーザーが半ば無意識に使っていた基準らしきものの内容の言語化を試みた程度のものである. 磨き込みは足りてないと思う. 参考程度に読んで欲しい.

一般論を扱おうとすると内容が膨大になってしまうので, この記事では数式コマンドのデザインだけに焦点を当てる. この点に絞る理由は以下の通り:

- 可読性・保守性のボトルネックになるのは数式環境であり, その主要構成要素は数式コマンドであること
- ソースコードの書き方云々以前に, 使おうとしている数式コマンド自体に難がある例が(私が観測する範囲では)多いこと
- これらは少数の指針で修正可能である(と私が思っている)こと

内容は, どんなコードが `document` 環境に書かれるべき・書かれるべきでないか, という点に集中する. `\newcommand` や `\NewDocumentCommand` を使ったコマンドの定義方法の解説などは一切解説しない.

## 可読性・保守性

$\LaTeX$ の文脈で可読性・保守性が語られることは, あまり多くないように見受けられる.
念のため, その文脈に寄せて簡易に概念を定義し, 大雑把な認識の共有を図る.
普段からプログラミング等でコードを書いていて, これらの概念に慣れ親しんでいる人は読み飛ばしてよい.

- 美的一貫性
- 可読性・自己説明性
- 保守性

### 美的一貫性

ソースコードの書き方に, 美的合理性・一貫性があり, 読み手に優しいレイアウト・記述形式であること.

- (美的一貫性のある)良い例
  - 1行1文が守られている
  - `\alpha \in \MySet` のように, 意味のある最小単位ごとに space で区切られている
  - `equation` 環境などの階層構造が適切にインデントで表現するルールがある
- (美的一貫性のない)悪い例
  - インデントの方法・量が場所によって異なる

美的一貫性のある書き方の解は無数にあるので, そのうちの1つを書き手の好みに応じて選び, それを実現させる Formatter を用意すればよい. それ以降は Formatter に仕事を丸投する. 広義には, この概念は可読性に含まれるが, 現代においては人間が積極的にやるべき仕事ではないことを考慮して可読性概念から分離した.

### 可読性・自己説明性

**他者(将来の自分を含む)が**ソースコードから意味・表示内容(のどちらか重要な方)を正しく読み取れること. その読解が, 少ない時間・労力・ストレスで実現できること.

- 良い例
  - 意味を明確にするネーミング: `t{A}` ではなく `\transpose{A}`
  - ソースコードの音読がPDFの音読と近い (WYSIWYG的である)
- 悪い例
  - 表示も意味も想像できないコマンド名 `\res{A}`
  - 非直観的な引数を持つコマンド `\~{A}{}{i_1}`
  - 出力 pdf 以外のヒントが少ないコード

ツールに任せる美的一貫性と異なり, 人間の積極的作為によって担保すべき条件. 次の保守性も同様.

### 保守性

外界の変化の強く, また変更が容易であること. 変更時の影響範囲が最小限の範囲に限定されていること. その範囲を変更前に正確に予見できること.

- 良い例
  - それぞれのコードの役割分担に, 読み手に伝わる明確なポリシーがある
- 悪い例
  - 変更の可能性があるパッケージの関数が `document` 環境内にベタ書きされている
  - `document` 環境内で1つのコマンドが複数の意味で使われている
  - 必須引数が多くて変更が困難なコマンド `\command{x}{\alpha}{}{1}`
  - 多くのコマンドの合成から成る複雑な依存関係を持つコマンド

## 良いコマンドの条件

「可読性・保守性の高いコードを書きましょう!」の掛け声でそれが実現されるなら苦労はない. そのようなコードに書き手を誘導する実行可能な指針が必要だ. そのような指針の構成要素の1つとして, 以下のような「良いコマンドの条件」を提案したい.

- 名が体を表すこと
- 唯一つの対応概念を持つこと
- 最小限のインターフェースであること

"良い"の意味は, もちろん可読性・保守性の高さを指す.
経験上, この条件を満たすコマンドは実際にこの意味で良いものに自然と仕上がりやすい.
良いコマンドであるための必要条件でも十分条件でもないだろうが, 良いコマンドを目指す上での少数の指針として有用であると考える.

### 名が体を表すこと

説明不要なほど当然のルールだが, 念のため. コマンドには読み手がその機能を想像でき, かつ他のコマンドと容易に区別できる示唆的な名前を付けるべきだ. 過度な略称は控えた方がよい. 意味の伝わらない短い名前より, 冗長でウザい名前の方がずっと良い.

たとえば, 置換群(Symmetric Group)を意図するコマンドなら `\sg{n}` ではなく, `\symGrp{n}` くらいまで書いた方が読み手に確実に伝わる.

### 唯一つの対応概念を持つこと

ここで言う対応概念とは, その文書に登場する概念のいずれかで, その分野で一般的に認められている固有名詞を持つ概念を指す. たとえば, `\newcommand{\transpose}[1]{ #1 ^\mathsf{T}}` の対応概念は転置, `\derivative` の対応概念は微分という具合だ.

言われてみると当然だが, この基準を破ったばかりに, 扱いづらくなってしまったコマンドを非常によく見かける. 自然な所作であるという理解はされているが, その効用自体があまり理解されていないのだろう.

では, 唯一つの対応概念があると何がよいか.

可読性の観点から言えば, 読み手がそのコマンドの意味を理解しやすいことがまず挙げられる.
対応概念があるなら, そのコマンド名が自然に決まり, 名が体を表すようになる. `\transpose{A}` とだけ見れば行列 `A` の転置だと分かるから, コマンドの定義まで遡る手間が省ける.

また, その周辺のコードの意味も理解しやすくなる.
一般に, 読み手はその文書の内容(コードではなくPDF上の内容の方)についての理解を完全ではないものの部分的には持っている.
その知識がソースコードの読解に利用できるようなスタイルでソースコードを書いておけば, 読み手がソースコードを読む際のヒントが増え, 読解の負担軽減が期待できる.
たとえば, `\transpose{A} y` を見たとき, `y` について何の説明もされなくても, `y` は `A` の行数に等しい次元を持つベクトルだと想像がつくだろう.
この読解方法は, そのソースコード特有のルールや属人的な知識を前提としないので, 汎用的に使える方法でもある.
対応概念の候補が複数あると読み手の推測の精度が落ちるので, 対応概念は1つだけがよい.

保守性の観点からは, コマンドが, "文書が扱う概念・話題それ自体"に対して定義され, レイアウトや文章構造, コンテンツの表示方法, 記号の選び方等の目先の要素とは独立になることが挙げられる. 厳密には, コマンドの"出力"は特定の記号の選び方に依存するが,

$$概念→その記号$$

という自然な対応が出来上がるので, 記号管理に関心がある文脈における依存関係としては最も都合が良い.

1つのコマンドに対応する概念が1つだけなら, そのコマンドの中身を変えても変更の影響はその概念に対応する部分だけに収まり, 他所にまで変更の影響が波及することはない. 1つの概念には1つのコマンドだけが対応するなら, なお管理が楽になる.

ここでは, 可読性・保守性に絞って対応概念の存在意義を述べたが, もちろんこれが全てではない. 後に見るように, 対応概念の存在は種々の便利な判断基準を与えてくれる.

### 最小限のインターフェースであること

::::details インターフェースとは (プログラミング未経験者向け)
:::message

以下は, 一般的なインターフェースの説明ではありません. この記事の目的に合わせて意味を狭めたり, 強調する点が変更されています.
:::

インターフェースとは, 自分自身の入出力のパターンを宣言・公開し, その動作を保証することを約束したもの. 内部処理の方法には言及せずに, 外界に対して自分がどう振る舞うかだけを約束する.

たとえば, `\mathbb` コマンドを使うとき, ユーザーは入力の引数に対する結果の表示のパターンしか知らない. 内部でどういう実装をしてるかはユーザーは気にしない. アプデ等で内部処理の方法に修正が入ったとしても, 今までと同じ方法で引数を与えて黒板文字の出力を得られることは変わらないはずだとユーザーは信じている. この引数と出力の表示の組がまさに `\mathbb` のインターフェースだ. ユーザーは内部実装の詳細に関わらず不変に提供されるインターフェースを暗に理解していて, 普段から暗に利用している.

このように, 内部処理の詳細をブラックボックスとする代わりに, 入出力の型の不変性を外部に対して保証するのがインターフェースの特徴的役割だ.
::::

自作コマンドは `document` 環境に対して宣言・公開するインターフェースとして扱うとよい. コマンド名から想像される自然な入出力形式を持たせ, その内部処理の詳細を問わず, 一度決めた入出力形式だけを長期にサポートすることに専念させる. 具体的には,

- コマンド名の本質的意味
- 入力: 並び順も含めた自然な必須引数 + オプション
- 出力: コマンド名が指す表示対象

を今後変更しない前提で定義する(正確には, 後方互換性を持たせられるならオプションは途中で増やしてもよい). それ以外のコマンド定義の中身はいくらでも変えてよい. 代わりに, 中身の変更の必要が生じてもこれらの外面を維持できるように定義する. つまり, 記号の変更時の対応箇所は該当コマンドの中身を修正するだけで済み, `document` 環境のコードを変更しなくても済むようにする. **これを守れる見込みのないようなコマンドは初めから定義しない.**

:::message
【補足】
ここで言う「インターフェース」のニュアンスは, 変更前の使用方法を変更後もサポートするという点で後方互換性の概念とも近い. しかし, 個々の具体的な内部処理には興味がなく, サポート対象の固定的な入出力形式にだけ興味があるという点を強調するために, インターフェースという言葉を敢えて使っている.
:::

もちろん, 将来起こる変更を現時点で想定し尽くすことは不可能だ. そんな神業は求めていない. ここで要求していることは, 1つのコマンドの仕事と仕様はシンプルなものと約束しておき, 難しい変更要求がそのコマンドに降って来たり, 別の2コマンドへ解体されることがないように, 自身の役割は十分に小さく定義しよう, ということだ.

「最小限」が意味するところは, まさにこの点であり, 想定入力のパターンは欲張らずにコマンド名から想像される自然なものに留めるべし, という念押しだ. 多様な入力パターンを認めることは, 多機能主義や実装の複雑化, 影響範囲の肥大化などに繋がり, 破綻可能性と破綻時のリスクサイズをいたずらに大きくする.

最小限のインターフェースを持つコマンドは, 余計な引数やオプションを持たないだろうから, 簡素なものになっているはずだ. あとはコマンド名が自然であれば, 読み手が解釈しやすい対象になることが期待できる. このようなコマンドが保守性に優れることは明らかだろう.

単にコマンドはシンプルに作れ, という掛け声に過ぎないように聞こえるかもしれない. そのメッセージが非常に重要なことは否定しない. しかし, 単にそれだけに収まるわけでもない. 次に見るように, これら2条件は実用的な手続きを誘導する.

## 良いコマンドを作るプロセス

### コマンドは外面から決める

`\concept` という名前のコマンドを定義しようとしているとしよう. 名前と対応概念以外は何も決まっていないとする.

コマンドを定義するとき, プリアンブルやstyファイルの中でどう中身を与えて定義するかという問題に意識が集中する人が多いと思う. コマンドの中身は100%自作するか, あるいはパッケージからパーツを借りて来るのか, それともまるっきりパッケージの関数を wrap するだけにするのか etc. それらは全て後回しにしよう. コマンドのインターフェースとしての役割を重視する立場からすると, それらははっきり言ってどうだっていい.

真っ先に考えるべきは, `\concept` コマンドが `document` 環境の中でどう呼び出されるべきかを決める作業だ. `document` 環境に公開するインターフェースの検討会議だ. 一度公開した後, オプション引数の追加やコマンド本体の微修正だけで長期間生き残るように, コマンドの対応概念を表現するのに必要十分な直観的な外面を用意しなければならない. ここをサボると後でもう一度考え直す羽目になる. その間に書いた半端な `\concept` コマンドの修正タスクも発生するはずなので時間を失うばかりだ.

具体的に確定させるべきは入出力の内容だ. 今は `\concept` が対応概念を持つと仮定しているので, 実は出力に関して決めることはない. 出力する記号を決める必要があるじゃないかと思うかもしれないが, 記号は仮置きで構わない. 対応概念の記号の影響範囲はこのコマンドだけだろうから, いつでもほぼゼロコストで変更できるからだ.

実質的課題は入力引数の決定だ. 様々な候補があるうち, どの引数を受け入れ, どの引数を受け入れないのか. 受け入れることにした変数のうち, どれを必須とするのか. 引数はどんな順番で並べるのか. 全て決める必要がある(決め方の指針は以下で詳しく述べる).

これらが決定して初めてコマンドの中身の実装作業に入る. コマンドの中身は完全に完成していなくても, (コンパイル等に支障がないなら)今すぐ完成させる必要はない. 部分的に仮置きの状態でその文書の続きを書いても全く問題ない. たとえば, もし `\concept[val1]{arg}[opt2=val2, opt3=val3]` のような形と決まったなら, `opt*`の名前だけ決めて, その他の値の出力値は仮置きして実装を先送りしてしまっても構わない.

`document` 環境で `\concept[v1]{x}[opt1=v2, opt3=v3]` と呼び出せるようになっているのなら, そのコマンドの役割は決定されたも同然だ. `\concept` コマンドがコミットすべきは `document` 環境における役割であって, 自身の定義の詳細ではない. その役割が決定されたのであれば, 残りの部分はいつか実装されれば問題ない. その完成タイミングはいつになっても構わない. 極端なことを言えば, 文書の大半の完成を見届けるまでコマンドの実装を渋っても構わない.

その意味では, コマンドは外面から決めるというより, コマンドは外面**だけ**決めるの方が実態に近い.

### 「自然な」引数の選び方

自然なコマンド引数を選ぶべきことなど百も承知なはずだろうが, 頭で分かっているだけでは足りない. コマンド引数の「自然さ」の判断基準が欲しい. どんなものが有り得るだろうか.
残念ながら, 一般には, そのコマンドの役割・目的に依存して無数の基準が有り得る.
したがって, その時々で恣意的な基準を選ぶことで自分の選択に対する自己批判をかわすことはいくらでもできる. これが多機能主義的なコマンドが産まれる背景の1つだろう.
しかし, 対応概念を持つコマンドに絞れば便利な基準がある. すなわち, **引数の候補が対応概念の中で自然な要素であるか**というテストを判断基準として使える. これによって, 過ぎた多機能化を予防できる.

たとえば, 導関数を対応概念に持つ `\derivative` というコマンドがあったとしよう. たとえば, $\frac{\partial^3 f}{\partial x_1 {\partial x_2}^2}$ という出力を行うものだ.
必須引数かオプションかは一旦置いておいて, このコマンドにとって自然な引数に, 微分可能関数 $f$, 微分を行う変数を指す ${x_1, x_2}$, そのオーダーを指す `{1, 2}` が含まれることに違和感はない. $f$ が1変数関数のときは $\partial$ ではなくて $d$ を使うのが慣習だから, この記号を切り替えるフラグ変数が含まれることにも異論はない. なぜなら, そのそれらは微分操作とその標準的記法において自然に存在するもの達だからだ.
その導関数のある点$p$での評価値 $\left . \frac{\partial f}{\partial x_1}\right|_{p}$ を, (たとえば `\derivative{f}{x_1}[p]` のような形で)引数に含めるべきかは意見が分かれ得る. コマンド名の derivative は微分係数も含むからそれに相当する評価値をコマンドに取り込むのは自然という意見もあれば, 値の評価は微分操作とは別概念だから, `\eval{function}{at}` のようなコマンドを別に定義してそれに処理させるべきだという反対意見も有り得る.
他方で, $f$ の頭にハット $\hat{f}$ やチルダ $\widetilde{f}$ を乗せる選択肢を与える引数は明らかに不自然だ. 微分操作と何の関係もないからだ. $x$ の下付き添字をたとえば `\derivative{f}{x}[order={1,2}, subscript={1,2}]` のように指定する引数はやや不自然に思える. 関数の引数は必ずしも $f(x_1,\ldots,x_i,\ldots,x_k)$ のように書かれるとは限らないからだ.

このように, 明確な対応概念を持つコマンドであれば, 不自然な引数の大半をこの基準で弾ける. 意見の分かれそうな少数の引数についてだけ, 可読性・保守性を天秤にかけて採用するか個別に判断すればよい. パッケージとして公開するコマンドでない限り, 経験的に, 1つの文書で1つのコマンドに必要な引数の数はそう多くならないはずだ. (私は引数が5以上のものは滅多に作らない.)

### 必須引数の決め方

引数のセットが決まったら, それらを必須引数とオプションに振り分けていくことになる. `\command{}{x}[y]` のように必須引数は空にならないように定義するのが基本だ. 空の `{}` は可読性を損なうので極力ない方がよい. 空になる用途が有り得るなら, その引数はオプションに逃がす.

:::message
必須引数は, コマンドの用途を意図通りのものに限定する役割がある一方で, 無計画に増やすと変更に弱くなる上に可読性を損ないやすい.
:::

もし `\command{}{x}` に積極的な意味があるなら(特に対応概念があるなら), そのパターンは1つのコマンドとして独立させることを検討した方がよいかもしれない.

たとえば, `\derivative{}{t}` $\frac{\partial}{\partial t}$ に時間微分作用素としての意味を与えているなら, `\timeDifferential` のようなコマンドを `\derivative` の特殊化として定義し, `\derivative{}{t}` と書くことを辞めた方がコードが解釈しやすくなる. もしくは, `\derivative{}{x}` の別名として, `\diffOperator{x}` などを定義してもよいかもしれない.

### 引数の並び順の決め方

引数の並び順も自然であるに越したことはない. 自然な基準は主に2つある.

- 引数の並び順の選択肢: 例 $\int_I f dx$
  - 数式として表示される順: `\integral[I]{f}{x}`
  - 読み上げ順: (integration of $f$ with respect to $x$ over $I$) `\integral{f}{x}[I]`

ソースコードと PDF の対応を重視するなら前者, ソースコードを自然言語に近付けることを重視するなら後者ということになるだろうか. どちらでも構わないが, 採用する方針は固定して文書中で一貫させた方が読み手が混乱せずに済む.

なお, 当然だが, 読み上げ順は何らかの対応概念の存在を前提としている. このような形で読み上げることができないコマンドは, 何らかの改善の余地がある場合が多い。

### オプションの実装方法

柔軟なオプション定義やkey-value形式のコマンド定義を可能にするパッケージがある. 執筆時点で代表的なものを挙げておく.

- keyval
- xkeyval
- xparse
- l3keys

パッケージの使用法の詳細は, 公式ドキュメントなどに譲る.

### コマンドとスニペットはペアで定義する

コマンドの外面を固めた後に必ずやるべきことがある. そのコマンドへのスニペットの定義だ.

大前提として, コマンドに対する入力支援の仕組みは必要不可欠だ. これがないと, 入力に時間がかかったり, それを嫌って不自然に短いコマンド名を付けるようになる. コマンドオプションの key が非直観的な略語だらけになり, 可読性を損なうことさえ有り得る. コマンド入力は面倒を感じないレベルまで高速化できる体制を必ず整えよう.

もし, そのような入力支援環境を整えられないテキストエディタを使っているなら, 可読性云々以前にその作業環境自体にそもそも問題がある. このような下流についての記事は今すぐ閉じて, LaTeX の環境構築について学ぶ等, 快適な作業環境の確保にリソースを振った方がよい.

やや蛇足. 上で, 1つのコマンドの過剰多機能化は保守性の観点から望ましくないと書いた. 同じことがスニペットによる入力支援の観点からも言える. たとえば, あるコマンドに10個のオプション引数があるとしよう. そのスニペットを打つたびに10個のオプション全てがサジェストされたらウザったくて仕方ないだろう. 大半のケースでは, せいぜい3~4個しかオプションは使わないのだから. こういうケースに出会ったら過剰機能を疑った方がよい.

## 省略用コマンド

良いコマンドの作り方を論じた直後に話の腰を折るようだが, 悪いコマンドの作り方を紹介する.

"良いコマンド"だけで全てが足りれば幸せだが, 現実には複雑なコードの見た目をどうしても圧縮する必要があるなどの理由で, しょうもないコマンドをスポットで用いざるを得ない場合もある. そういう状況では, その目的専用と割り切った省略用コマンドとして定義して使おう. 次のような, 省略したい表現への純粋なショートカットとして用いるコマンドを指す.

```tex
\newcommand{\AbbreviationCommand}[n]{省略したい複雑な表現}
```

省略用コマンドはコメントで指す対象を宣言して使う.

```tex
... &= \some \terms \frac{complex}{terms} \\
% 前の行の最後の分数のマクローリン展開の3次の項までを \xxMacExp{a}{x}{f} とおく
    &= \some \terms + \xxMacExp{a}{x}{f}
```

つまり, 板書とかでやる「この部分をAとおく」をコードでやる.

省略用のコマンドはそうでない通常コマンドと区別できるようにprefixを決めておくとよい. 上の例ではxxとした.

また, 省略用のコマンドはその場で使い捨てて再利用しないこと, つまり, 影響範囲をソースコードの一部分に限定することが鉄則. 省略用コマンド自体は可読性等に難のある"酷い"コマンドなので, 散在させて得なことなど何もない. 必要悪として瞬間的に利用せざるを得ない場面があるだけだ.

省略用コマンドには, 上で議論したようなコマンドに対する工夫は必要ないが, 省略コマンドで束ねる対象は対応概念があるコマンドに限定した方が省略用コマンド自体の保守性は良くなる.

省略用コマンドはあくまで最後の手段であり, これに頼る前に検討すべき相対的にマシな方法がいくつかある. 次の節では, そのような例のいくつかを紹介する.

## コマンド化する・しないの判断基準例

当然ながら方針は以下の通り.

- コマンド化する・しないの基準
  - 可読性・保守性に寄与しないならコマンド化しない
  - この両方に寄与するならコマンド化する
  - 一方を犠牲にして他方を立てるケースは個別判断

これらの類型に当てはまる典型例を挙げる. 中には, 上で議論した良いコマンドの条件に必ずしも当てはまらないが, コマンド化した方がよい例もある.

なお, 以下は重要度順等ではなく, 説明する上で都合がよい順.

### 記号変更の可能性があり, 登場回数の多い概念があるとき → する

このような概念はコマンドという単位で管理することを考えた方がよい. 可読性が増すかは現状の記号次第だが, 記号の変更が起きてしまったときの保険として有用な場合が多い.

たとえば, xxx空間をたくさん扱っていて, 大文字の記号 $X$, $Y$,...etc. が入り乱れているような状況を考えよう. このようなときは, 空間概念ごとに, たとえば `\BanachSp{X}`, `FrechetSp{V}` などのようにコマンドで仕切っておくとよい. 記号変更が起きたとき, たとえば Frechet 空間だけ `mathcal`に変えたくなったとき等にとても助かる.

### 1つの記号が用途によって異なる概念を指すとき → する

先のケースの特殊版に当たる.

同じ記号を共有する概念のうちのどれか1つに記号変更が生じた場合, `document` 環境での置換作業が非常に面倒になる. 記号用途の重なりが発生した時点で, 少なくともその片方は, 現時点の出現回数を問わずコマンド化した方がよい.

たとえば, 集合 $A$ の内部を `A^{\circ}` $A^{\circ}$, 関数の合成を `g \circ f` $g \circ f$ と書いているなら, 可読性への寄与を考慮して, 前者を `\interior{A}` として定義した方がよいだろう.
もちろん, 同時に後者を `g \composite f` などとコマンド化してもよい.

### 1つのコマンドの制限が別の対応概念を持つとき → する

典型的には, 用途の広いパッケージの関数を `document` 環境にベタ書きするときに発生しやすい.

たとえば, derivative パッケージの `pdv` や diffcoeff パッケージの `\diffp` は, 導関数 $\frac{\partial f}{\partial x_1}$ , 微分作用素 $\frac{\partial}{\partial t}$, 接空間の基底 $\frac{\partial}{\partial x_i}$...etc., という風に複数概念を表現できてしまう.

このような場合は, パッケージ関数を特殊化・制限して, 対応概念ごとにコマンド化した方が可読性も増す上に Notation の管理もしやすくなる. たとえば, `\derivative`, `\diffOpt`, `\tanBasis` のようなコマンドを作るとよいだろう.

### 合成コマンドが明確な対応概念を持つとき → する

コマンドの合成の乱用は依存関係を複雑にして, 保守性を下げる場合があるので慎重になるべきということはまず明言しておく.
しかし, このような合成の需要は, 主に可読性の向上等を目的として多々発生することも事実だ.
これを概ね安全に行える類型として, ミニマルに定義されたコマンド同士の合成が再び対応概念を持つケースが挙げられる.

たとえば, 接空間の基底の変換則が(Einstein の縮約ルールを使って)以下のように書かれているとする.

$$ \left .\frac{\partial}{\partial x_{i_1}}\right|_{p} = \frac{\partial \widetilde{x}_{j_1}}{\partial x_{i_1}}(p) \left .\frac{\partial}{\partial \widetilde{x}_{j_1}}\right|_{p} $$

そして, 右辺に対応するコードは

```tex
\derivative{\~{x}_{j_1}}{x_{i_1}}(p) \tanBasis{\~{x}_{j_1}}[p]
```

と書かれていたとする. この部分は変換則そのものに対応する

```tex
\tanBasisTrans{from=x_{i_1}, to={\~{x}}, subscr=j_1}[p]
```

のようなコマンドを定義して置き換えると可読性が上がり, 意味も明確になる. その実装は, 既存のコマンドを併記するような内容になるので, 直観的でメンテナンスが楽な内容に収まりやすい.

ただし, 可読性の向上などが見込めない状況で合成コマンドを定義するメリットはない. また, このような合成コマンドをさらに合成することも無しではないが, 保守性が犠牲にならないかなど十分な注意を持って判断されるべきだろう.

### 操作内容を端的に呼べるとき → する

コマンドの(合成)内容が固有名詞としての対応概念を持たなくても, その操作内容を(対応概念と関連のある形で)端的に呼べるのであれば, 広義の対応概念を持っているようなものだ. この場合はコマンド化する利益がある場合が多い. たとえば,

$$
\int_{\Omega} \left( \frac{\partial u_n}{\partial x_i} v_n + u_n \frac{\partial v_n}{\partial x_i} \right) \varphi
$$

という積分を次のようなコードで書いているとして,

```tex
\integral{\left( \derivative{u_n}{x_i} v_n + u_n \derivative{v_n}{x_i}\right) \varphi}[over={\Omega}]
```

このコードの可読性を上げることを考える. `\derivative` 周りの対称性を利用してなんとかする方法も有り得るが, 今は `(\derivative +...)` を別の関数 `\varphi` と掛け合わせた上で積分するという定型的な操作に注目し, 以下のように"別の関数と一緒に積分する"という操作を表現するコマンドを定義する.

```tex
\integralWith{f=\derivative{u_n}{x_i} v_n + u_n \derivative{v_n}{x_i}, with=\varphi}[over={\Omega}, bracket=true]
```

`with=` を導入して掛け算の切れ目を明らかにすることで, brackets `()` の挿入を `bracket=` オプションに任せられ, コードの意味が見えやすくなった.

このような操作的なコマンドは, key-value形式のような説明的な仕立てにするとよい. 狭義の対応概念を持つ場合と比べて口語的なコマンド引数と相性がよい.

なお, この操作だけなら `\integral` に `with=`, `bracket=` オプションを足せば足りる. ここでは, 積分(や微分)コマンドは放っておくと機能が肥大化していくことを危惧して, 初めから独立させることを選んだ. この判断は書いている文書やユーザーの好みに依存するだろう.

### 入力速度を上げたいだけのとき → しない

コマンド化せず, その内容を高速入力するスニペットを定義した方が良い.

ソースコード上に残す文字は, 入力完了時点からそれ以降の将来に向かって継続する情報的価値が求められる. 書き終わった瞬間的に価値を失うなら, それは負の遺産となる. そんなコマンドは存在しないに越したことはない. コードは書く時間よりも読まれる時間の方が長いので, 書く際の都合よりも読む際の都合を優先すべきだ.

### 対応概念が定まらない記号を含むとき → しない

典型例には, 意味を持たない `\tilde` や `\prime` がついているコードがこの類型に当てはまる.

たとえば, `\tilde{f}` に対応概念がない場合, これは単に `f` と比較するためにチルダを付けただけの `f` とは関連のない関数であることが多い. この記号を使うべき理由はなく, `f_1` でも `\prime{f}` でも `g` でも別に構わないはずだ.

そのため, 記号が変更される可能性は他と比べて高いし, 変更される箇所は気まぐれで法則性がないことが予想される. つまり, コマンドによる記号管理と相性が悪い. なぜなら, 同管理法は, 変更がある場合は一括変更であること前提としていて, 局所変更は想定していないからだ. この手の場当たり的記号をコマンド内に引き込むと保守性が著しく損なわれる. よって, 完全に締め出した方がよい.

対応概念が定まらない記号を含むコマンド合成は無論ご法度で, できれば省略コマンドにさえ含めない方がよい. `\xxAbbreviation{x}{\~f}` のようにコマンド定義には含めず引数の値として与える方が安全だ.

コマンドが対応概念を持つことが如何に重要かを示す好例ではないだろうか.

### コマンドに付ける添字管理がしたい → ?

ここで言う「添字」は, 数字に当たるものだけでなく, 記号も含む. たとえば, $P_X$ の $X$ も添字として扱う.

上で, `\derivative` コマンドの引数として, `\derivative{f}{x}[order={1,2}, subscript={1,2}]` のような添字管理オプションは自然ではないと書いた. これは個別例であり, 添字管理するコマンドやオプション全般についてそう言っているわけではない.

その標準的表記法に添字が込められていると見なせる概念は多くある. その場合は, 対応概念のコマンドに添字管理用のオプションを与えることは自然だろう.

たとえばノルムや内積, 距離などの特定の空間に付随する計量関数は, 本来その空間を明示して `\norm{f}_X` などと書くべきだ. 文脈から明らかな場合は省略して単に `\norm{f}` と書く慣習があるに過ぎない. この省略内容を明示するオプションはむしろある方が自然だろう.

`\norm{f}_X` や `\norm{f}_1` のような書き方しかしないと決まっているならコマンド化の必要性は薄れるが, ノルム空間に対する Notation を `\NormSp{X}` のようなコマンドで管理している場合は特に, 添字管理をコマンドで行った方がよい. `\norm{f}_{\NormSp{X}}` は明らかに冗長だし, braces `{}` の連続も目に優しくない. 代わりに, `\norm{f}[space=X]` などと書けるようにするとよいだろう.

類似例として, 写像等が誘導・生成する概念はこのような添字管理方法が自然な場合が多い. たとえば, 包含写像 $i: W \to X$ が引き起こす相対位相 $\mathcal{O}_W$, 確率変数 $X$ が引き起こす確率測度($X$ の分布) $P_X$ などがそれに当たる.
