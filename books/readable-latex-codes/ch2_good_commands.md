---
title: "良いコマンドの条件"
---

<!-- ## 良いコマンドの条件 -->

「可読性・保守性の高いコードを書きましょう!」の掛け声でそれが実現されるなら苦労はない. そのようなコードに書き手を誘導する実行可能な指針が必要だ. そのような指針の構成要素の1つとして, 以下のような「良いコマンドの条件」を提案したい.

- 名が体を表すこと
- 唯一つの対応概念を持つこと
- 最小限のインターフェースであること

"良い"の意味は, もちろん可読性・保守性の高さを指す.
経験上, この条件を満たすコマンドは実際にこの意味で良いものに自然と仕上がりやすい.
良いコマンドであるための必要条件でも十分条件でもないだろうが, 良いコマンドを目指す上での少数の指針として有用であると考える.

### 名が体を表すこと

説明不要なほど当然のルールだが, 念のため. コマンドには読み手がその機能を想像でき, かつ他のコマンドと容易に区別できる示唆的な名前を付けるべきだ. 過度な略称は控えた方がよい. 意味の伝わらない短い名前より, 冗長でウザい名前の方がずっと良い.

たとえば, 置換群(Symmetric Group)を意図するコマンドなら `\sg{n}` ではなく, `\symGrp{n}` くらいまで書いた方が読み手に確実に伝わる.

### 唯一つの対応概念を持つこと

ここで言う対応概念とは, その文書に登場する概念のいずれかで, その分野で一般的に認められている固有名詞を持つ概念を指す. たとえば, `\newcommand{\transpose}[1]{ #1 ^\mathsf{T}}` の対応概念は転置, `\derivative` の対応概念は微分という具合だ.

言われてみると当然だが, この基準を破ったばかりに, 扱いづらくなってしまったコマンドを非常によく見かける. 自然な所作であるという理解はされているが, その効用自体があまり理解されていないのだろう.

では, 唯一つの対応概念があると何がよいか.

可読性の観点から言えば, 読み手がそのコマンドの意味を理解しやすいことがまず挙げられる.
対応概念があるなら, そのコマンド名が自然に決まり, 名が体を表すようになる. `\transpose{A}` とだけ見れば行列 `A` の転置だと分かるから, コマンドの定義まで遡る手間が省ける.

また, その周辺のコードの意味も理解しやすくなる.
一般に, 読み手はその文書の内容(コードではなくPDF上の内容の方)についての理解を完全ではないものの部分的には持っている.
その知識がソースコードの読解に利用できるようなスタイルでソースコードを書いておけば, 読み手がソースコードを読む際のヒントが増え, 読解の負担軽減が期待できる.
たとえば, `\transpose{A} y` を見たとき, `y` について何の説明もされなくても, `y` は `A` の行数に等しい次元を持つベクトルだと想像がつくだろう.
この読解方法は, そのソースコード特有のルールや属人的な知識を前提としないので, 汎用的に使える方法でもある.
対応概念の候補が複数あると読み手の推測の精度が落ちるので, 対応概念は1つだけがよい.

保守性の観点からは, コマンドが, "文書が扱う概念・話題それ自体"に対して定義され, レイアウトや文章構造, コンテンツの表示方法, 記号の選び方等の目先の要素とは独立になることが挙げられる. 厳密には, コマンドの"出力"は特定の記号の選び方に依存するが,

$$概念→その記号$$

という自然な対応が出来上がるので, 記号管理に関心がある文脈における依存関係としては最も都合が良い.

1つのコマンドに対応する概念が1つだけなら, そのコマンドの中身を変えても変更の影響はその概念に対応する部分だけに収まり, 他所にまで変更の影響が波及することはない. 1つの概念には1つのコマンドだけが対応するなら, なお管理が楽になる.

ここでは可読性・保守性に絞って対応概念の存在意義を述べたが, もちろんこれが全てではない. 後に見るように, 対応概念の存在は種々の便利な判断基準を与えてくれる.

### 最小限のインターフェースであること

::::details インターフェースとは (プログラミング未経験者向け)
:::message

以下は, 一般的なインターフェースの説明ではありません. この記事の目的に合わせて意味を狭めたり, 強調する点が変更されています.
:::

インターフェースとは, 自分自身の入出力のパターンを宣言・公開し, その動作を保証することを約束したもの. 内部処理の方法には言及せずに, 外界に対して自分がどう振る舞うかだけを約束する.

たとえば, `\mathbb` コマンドを使うとき, ユーザーは入力の引数に対する結果の表示のパターンしか知らない. 内部でどういう実装をしてるかはユーザーは気にしない. アプデ等で内部処理の方法に修正が入ったとしても, 今までと同じ方法で引数を与えて黒板文字の出力を得られることは変わらないはずだとユーザーは信じている. この引数と出力の表示の組がまさに `\mathbb` のインターフェースだ. ユーザーは内部実装の詳細に関わらず不変に提供されるインターフェースを暗に理解していて, 普段から暗に利用している.

このように, 内部処理の詳細をブラックボックスとする代わりに, 入出力の型の不変性を外部に対して保証するのがインターフェースの特徴的役割だ.
::::

自作コマンドは `document` 環境に対して宣言・公開するインターフェースとして扱うとよい. コマンド名から想像される自然な入出力形式を持たせ, その内部処理の詳細を問わず, 一度決めた入出力形式だけを長期にサポートすることに専念させる. 具体的には,

- コマンド名の本質的意味
- 入力: 並び順も含めた自然な必須引数 + オプション
- 出力: コマンド名が指す表示対象

を今後変更しない前提で定義する(正確には, 後方互換性を持たせられるならオプションは途中で増やしてもよい). それ以外のコマンド定義の中身はいくらでも変えてよい. 代わりに, 中身の変更の必要が生じてもこれらの外面を維持できるように定義する. つまり, 記号の変更時の対応箇所は該当コマンドの中身を修正するだけで済み, `document` 環境のコードを変更しなくても済むようにする. **これを守れる見込みのないようなコマンドは初めから定義しない.**

:::message
【補足】
ここで言う「インターフェース」のニュアンスは, 変更前の使用方法を変更後もサポートするという点で後方互換性の概念とも近い. しかし, 個々の具体的な内部処理には興味がなく, サポート対象の固定的な入出力形式にだけ興味があるという点を強調するために, インターフェースという言葉を敢えて使っている.
:::

もちろん, 将来起こる変更を現時点で想定し尽くすことは不可能だ. そんな神業は求めていない. ここで要求していることは, 1つのコマンドの仕事と仕様はシンプルなものと約束しておき, 難しい変更要求がそのコマンドに降って来たり, 別の2コマンドへ解体されることがないように, 自身の役割は十分に小さく定義しよう, ということだ.

「最小限」が意味するところは, まさにこの点であり, 想定入力のパターンは欲張らずにコマンド名から想像される自然なものに留めるべし, という念押しだ. 多様な入力パターンを認めることは, 多機能主義や実装の複雑化, 影響範囲の肥大化などに繋がり, 破綻可能性と破綻時のリスクサイズをいたずらに大きくする.

最小限のインターフェースを持つコマンドは, 余計な引数やオプションを持たないだろうから, 簡素なものになっているはずだ. あとはコマンド名が自然であれば, 読み手が解釈しやすい対象になることが期待できる. このようなコマンドが保守性に優れることは明らかだろう.

単にコマンドはシンプルに作れ, という掛け声に過ぎないように聞こえるかもしれない. そのメッセージが非常に重要であることは否定しない. しかし, 単にそれだけに収まるわけでもない. 次に見るように, これらの条件は実用的な手続きを導いてくれる.
