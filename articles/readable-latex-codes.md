---
title: "LaTeX コードの可読性・保守性を高めるコマンド作法"
emoji: "🙆"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["latex" ]
published: false
---

## 背景

$\LaTeX$ コードの可読性とか保守性が雑に扱われすぎ.

## 前提

- $\LaTeX$ 文書の大半を占める `document` 環境におけるコードの可読性・保守性を高める技法について議論する. 数理系の文書を想定.
- Formatter に任せるべき定型的・反復的仕事を除けば, `document` 環境におけるコードの工夫の余地は自作コマンドの使い方が多くの部分を握るので, 自作コマンドを中心に可読性・保守性を議論する.

## 可読性・保守性

$\LaTeX$ の文脈で可読性・保守性が語られることは, あまり多くないように見受けられる.
念のため, その文脈に寄せて簡易に概念を定義し, 目線の共有を図る.
普段からプログラミング等でコードを書いていて, これらの概念に慣れ親しんでいる人は読み飛ばしてよい.

- 美的一貫性
- 可読性・自己説明性
- 保守性

### 美的一貫性

ソースコードの書き方に, 美的合理性・一貫性があり, 読み手に優しいレイアウト・記述形式であること.

- (美的一貫性のある)良い例
  - 1行1文が守られている
  - `\alpha \in \MySet` のように, 意味のある最小単位ごとに space で区切られている
  - `equation` 環境などの階層構造が適切にインデントで表現するルールがある
- (美的一貫性のない)悪い例
  - インデントの方法・量が場所によって異なる

美的一貫性のある書き方の解は無数にあるので, そのうちの1つを書き手の好みに応じて選び, それを実現させる Formatter を用意すればよい. それ以降は Formatter に仕事を丸投する. 広義には, この概念は可読性に含まれるが, 現代においては人間が積極的にやるべき仕事ではないことを考慮して可読性概念から分離した.

### 可読性・自己説明性

**他者(将来の自分を含む)が**ソースコードから意味・表示内容(のどちらか重要な方)を正しく読み取れること. その読解が, 少ない時間・労力・ストレスで実現できること.

- 良い例
  - 意味を明確にするネーミング: `t{A}` ではなく `\transpose{A}`
  - ソースコードの音読がPDFの音読と近い (WYSIWYG的である)
- 悪い例
  - 表示も意味も想像できないコマンド名 `\res{A}`
  - 非直観的な引数を持つコマンド `\~{A}{}{i_1}`
  - 出力 pdf 以外のヒントが少ないコード

ツールに任せる美的一貫性と異なり, 人間の積極的作為によって担保すべき条件. 次の保守性も同様.

### 保守性

外界の変化の強く, また変更が容易であること. 変更時の影響範囲が最小限の範囲に限定されていること. その範囲を変更前に正確に予見できること.

- 良い例
  - それぞれのコードの役割分担に, 読み手に伝わる明確なポリシーがある
- 悪い例
  - 変更の可能性があるパッケージの関数が `document` 環境内にベタ書きされている
  - `document` 環境内で1つの記号が複数の意味で使われている
  - `document` 環境内で1つのコマンドが複数の意味で使われている
  - 必須引数が多くて変更が困難なコマンド `\command{x}{\alpha}{}{1}`

## 良いコマンドの条件

「可読性・保守性の高いコードを書きましょう!」の掛け声でそれが実現されるなら苦労はない. そのようなコードに書き手を誘導する実行可能な指針が必要だ. そのような指針の構成要素の1つとして, 以下のような「良いコマンドの条件」を提案したい.

- 唯一つの対応概念を持つこと
- 最小限のインターフェースを持つこと

"良い"の意味は, もちろん可読性・保守性の高さを指す.
経験上, この条件を満たすコマンドは実際にこの意味で良いものに自然と仕上がりやすい.
良いコマンドであるための必要条件でも十分条件でもないだろうが, 良いコマンドを目指す上での少数の指針として有用であると考える.

### 唯一つの対応概念を持つこと

ここで言う対応概念とは, その文書に登場する概念のいずれかを指す. たとえば, `\newcommand{\transpose}[1]{ #1 ^\mathsf{T}}` の対応概念は転置, `\derivative` の対応概念は微分という具合だ.

言われてみると当然だが, この基準を破った結果, 扱いづらくなっているコマンドを非常によく見かける.

唯一つの対応概念があると何がよいか.

可読性の観点から言えば, 読み手がそのコマンドの意味を理解しやすいことがまず挙げられる.
対応概念があるなら, そのコマンド名が自然に決まり, 名が体を表すようになる. `\transpose{A}` とだけ見れば行列 `A` の転置だと分かるから, コマンドの定義まで遡る手間が省ける.

また, その周辺のコードの意味も理解しやすくなる.
一般に, 読み手はその文書の内容(コードではなくPDF上の内容の方)についての理解を完全ではないものの部分的には持っている.
その知識がソースコードの読解に利用できるようなスタイルでソースコードを書いておけば, 読み手がソースコードを読む際のヒントが増え, 読解の負担軽減が期待できる.
たとえば, `\transpose{A} y` を見たとき, `y` について何の説明もされなくても, `y` は `A` の行数に等しい次元を持つベクトルだと想像がつくだろう.
この読解方法は, そのソースコード特有のルールや属人的な知識を前提としないので, 汎用的に使える方法でもある.
対応概念の候補が複数あると読み手の推測の精度が落ちるので, 対応概念は1つだけがよい.

保守性の観点からは, コマンドが, "文書が扱う概念・話題それ自体"に対して定義され, レイアウトや文章構造, コンテンツの表示方法, 記号の選び方等の目先の要素とは独立になることが挙げられる. 厳密には, コマンドの"出力"は特定の記号の選び方に依存するが,

$$概念→その記号$$

という自然な対応が出来上がるので, 依存関係としては最も都合が良い.

1つのコマンドに対応する概念が1つだけなら, そのコマンドの中身を変えても変更の影響はその概念に対応する部分だけに収まり, 他所にまで変更の影響が波及することはない. 1つの概念には1つのコマンドだけが対応するなら, なお管理が楽になる.

### 最小限のインターフェースを持つこと

::::details インターフェースとは (プログラミング未経験者向け)
:::message

以下は, 一般的なインターフェースの説明ではありません. この記事の目的に合わせて意味を狭めたり, 強調する点が変更されています.
:::

インターフェースとは, 自分自身の入出力のパターンを宣言・公開し, その動作を保証することを約束したもの. 内部処理の方法には言及せずに, 外界に対して自分がどう振る舞うかだけを約束する.

たとえば, `\mathbb` コマンドを使うとき, ユーザーは入力の引数に対する結果の表示のパターンしか知らない. 内部でどういう実装をしてるかはユーザーは気にしない. アプデ等で内部処理の方法に修正が入ったとしても, 今までと同じ方法で引数を与えて黒板文字の出力を得られることは変わらないはずだとユーザーは信じている. この引数と出力の表示の組がまさに `\mathbb` のインターフェースだ. ユーザーは内部実装の詳細に関わらず不変に提供されるインターフェースを暗に理解していて, 普段から暗に利用している.

このように, 内部処理の詳細をブラックボックスとする代わりに, 入出力の型の不変性を外部に対して保証するのがインターフェースの特徴的役割だ.
::::

良いコマンドの第2条件の「インターフェース」の意味するところは、自作コマンドにはコマンド名から想像される自然な入出力形式を持たせ, その内部処理の詳細を問わず, 一度決めた入出力形式だけを長期にサポートすることに専念させることにある. 具体的には,

- コマンド名の本質的意味
- 入力: 並び順も含めた自然な必須引数 + 公開済のオプション
- 出力: コマンド名が指す表示対象

を長期間維持できるように定義する. コマンド定義の中身の変更の必要が生じてもこれらを維持できるように定義する. つまり, 変更時の対応箇所はコマンドの定義だけで済み, `document` 環境のコードを変更しなくても済むようにする. **これを守れる見込みのないようなコマンドは初めから定義しない.**

:::message
【補足】
ここで言う「インターフェース」のニュアンスは, 変更前の使用方法を変更後もサポートするという点で後方互換性の概念とも近い. しかし, 個々の具体的な内部処理には興味がなく, サポート対象の固定的な入出力形式にだけ興味があるという点を強調するために, インターフェースという言葉を敢えて使っている.
:::

もちろん, 将来起こる変更を現時点で想定し尽くすことは不可能だ. そんな神業は求めていない. ここで要求していることは, 1つのコマンドの仕事と仕様はシンプルなものと約束しておき, 対応の難しい複雑な変更がそのコマンドに求められる可能性を予め削っておこう, ということだ.

「最小限」が意味するところは、まさにこの点であり, 想定入力のパターンは欲張らずにコマンド名から想像される自然なものに留めるべし, という念押しだ. 多様な入力パターンを認めることは, 多機能主義や実装の複雑化, 影響範囲の肥大化などに繋がり, 破綻可能性と破綻時のリスクサイズをいたずらに大きくする.

最小限のインターフェースを持つコマンドは, 余計な引数やオプションを持たないだろうから, 直観的で簡素なものになっているはずだ. したがって, コマンド名が酷くない限り, 読み手が解釈しやすい対象であることが期待できる. このようなコマンドが保守性に優れることは明らかだろう.

## 良いコマンドを作るための Tips

### コマンドは外面から決める

`\concept` という名前のコマンドを定義しようとしているとしよう. 名前と対応概念以外は何も決まっていないとする.

コマンドを定義するとき, プリアンブルやstyファイルの中でどう中身を与えて定義するかという問題に意識が集中する人が多いと思う. コマンドの中身は100%自作するか, あるいはパッケージからパーツを借りて来るのか, それともまるっきりパッケージの関数を wrap するだけにするのか etc. それらは全て後回しにしよう. コマンドのインターフェースとしての役割を重視する立場からすると, それらははっきり言ってどうだっていい.

真っ先に考えるべきは, `\concept` コマンドが `document` 環境の中でどう呼び出されるべきかを決める作業だ. いわば, `document` 環境に公開するインターフェースの検討会議だ. 一度公開した後, オプション引数の追加やコマンド本体の微修正だけで長期間生き残るように, コマンドの対応概念を表現するのに必要十分な直観的な外面を用意しなければならない. ここをサボると後でもう一度考え直す羽目になる. その間に書いた半端な `\concept` コマンドの修正タスクも発生するはずなので時間を失うばかりだ.

具体的に確定させるべきは入出力の内容だ. 今は `\concept` が対応概念を持つと仮定しているので, 実は出力に関して決めることはない. 出力する記号を決める必要があるじゃないかと思うかもしれないが, 記号は仮置きで構わない. 対応概念の記号の影響範囲はこのコマンドだけだろうから, いつでもほぼゼロコストで変更できるからだ.

実質的課題は入力引数の決定だ. 様々な候補があるうち, どの引数を受け入れ, どの引数を受け入れないのか. 受け入れることにした変数のうち, どれを必須とするのか. 引数はどんな順番で並べるのか. 全て決める必要がある(決め方の指針は以下で詳しく述べる).

これらが決定して初めてコマンドの中身の実装作業に入る. コマンドの中身は完全に完成していなくても, コンパイル等に支障がないなら, 部分的に仮置きの状態で執筆に戻っても全く問題ない. たとえば, もし `\concept[val1]{arg}[opt2=val2, opt3=val3]` のような形と決まったなら, `opt*`の名前だけ決めて, その他の値は仮置きして実装を先送りしてしまっても構わない. `document` 環境で `\concept[v1]{x}[opt1=v2, opt3=v3]` と呼び出せるようになっているのなら, そのコマンドの役割は決定されているも同然だ. 残りの部分の完成タイミングはいつになっても構わない.

その意味では, コマンドは外面から決めるというより, コマンドは外面**だけ**決めるの方が実態に近い.

### 「自然な」引数の選び方

自然なコマンド引数を選ぶべきことなど百も承知なはずだろうが, 頭で分かっているだけでは足りない. コマンド引数の「自然さ」の判断基準が欲しい. どんなものが有り得るだろうか.
一般には, そのコマンドの役割・目的に依存して無数の基準が有り得る.
したがって, その時々で恣意的な基準を選ぶことで自分の選択に対する自己批判をかわすことはいくらでもできる. これが多機能主義的なコマンドが産まれる背景の1つだろう.
しかし, 対応概念を持つコマンドについては, **引数の候補が対応概念の中で自然な要素であるか**というテストを判断基準として使って, そのような事態を予防できる.

たとえば, 導関数を対応概念に持つ `\derivative` というコマンドがあったとしよう. たとえば, $\frac{\partial^3 f}{\partial x_1 {\partial x_2}^2}$ という出力を行うものだ.
必須引数かオプションかは一旦置いておいて, このコマンドにとって自然な引数に, 微分可能関数 $f$, 微分を行う変数を指す ${x_1, x_2}$, そのオーダーを指す `{1, 2}` が含まれることに違和感はない.
$f$ が1変数関数のときは $\partial$ ではなくて $d$ を使うのが慣習だから, この記号を切り替えるフラグ変数が含まれることにも異論はない.
その導関数のある点$p$での評価値 $\left . \frac{\partial f}{\partial x_1}\right|_{p}$ を, (たとえば `\derivative{f}{x_1}[p]` のような形で)引数に含めるべきかは意見が分かれ得る. コマンド名の derivative は微分係数も含むからそれに相当する評価値をコマンドに取り込むのは自然という意見もあれば, 値の評価は微分操作とは別概念だから, `\eval{function}{at}` のようなコマンドを別に定義してそれに処理させるべきだという反対意見も有り得る.
他方で, $f$ の頭にハット $\hat{f}$ やチルダ $\widetilde{f}$ を乗せる選択肢を与える引数は明らかに不自然だ. 微分操作と何の関係もないからだ. 同様の理由で, $x$ の下付き添字をたとえば `\derivative{f}{x}[order={1,2}, subscript={1,2}]` のように指定する引数も不自然だ.

このように, 明確な対応概念を持つコマンドであれば, 不自然な引数の大半をこの基準でほぼ自動的に弾ける. 意見の分かれそうな少数の引数についてだけ, 可読性・保守性を天秤にかけて採用するか個別に判断すればよい. パッケージとして公開するコマンドでない限り, 経験的に, 1つの文書で1つのコマンドに必要な引数の数はそう多くならないはずだ. (私は引数が5以上のものは滅多に作らない.)

### 必須引数の決め方

引数のセットが決まったら, それらを必須引数とオプションに振り分けていくことになる. 基本的に `\command{}{x}[y]` のように必須引数は空にならないように定義する. 空の `{}` は可読性を損なうので極力ない方がよい. 空になる用途が有り得るなら, その引数はオプションに逃がす.

:::message
必須引数は, コマンドの用途を意図通りのものに限定する役割がある一方で, 無計画に増やすと変更に弱くなる上に可読性を損ないやすい.
:::

もし `\command{}{x}` に積極的な意味があるなら(特に対応概念があるなら), そのパターンは1つのコマンドとして独立させることを検討した方がよいかもしれない.

たとえば, `\derivative{}{t}` $\frac{\partial}{\partial t}$ に時間微分作用素としての意味を与えているなら, `\timeDifferential` のようなコマンドを `\derivative` の特殊化として定義し, `\derivative{}{t}` と書くことを辞めた方がコードが解釈しやすくなる. もしくは, `\derivative{}{x}` の別名として, `\diffOperator{x}` などを定義してもよいかもしれない.

### 引数の並び順の決め方

引数の並び順も自然であるに越したことはない. 自然の基準は主に2つある.

- 引数の並び順の選択肢: 例 $\int_I f dx$
  - 数式として表示される順: `\integral[I]{f}{x}`
  - 読み上げ順: (integration of $f$ with respect to $x$ over $I$) `\integral{f}{x}[I]`

ソースコードと PDF の対応を重視するなら前者, ソースコードを自然言語に近付けることを重視するなら後者ということになるだろうか. どちらでも構わないが, 採用する方針は固定して文書中で一貫させた方が読み手が混乱せずに済む.

### オプションの実装方法

柔軟なオプション定義を可能にするパッケージがある. 執筆時点で代表的なものを挙げておく.

- keyval
- xkeyval
- xparse
- l3keys

パッケージの使用法の詳細は, 公式ドキュメントなどに譲る.

### 【大前提】コマンドとスニペットはペアで定義する

コマンドに対する入力支援の仕組みは必要不可欠だ. これがないと, 入力に時間がかかったり, それを嫌って不自然に短いコマンド名を付けるようになる. コマンドオプションの key が略語だらけになり, 可読性を損なうことさえ有り得る. コマンド入力は面倒を感じないレベルまで高速化できる体制を必ず整えよう.

もし, そのような入力支援環境を整えられないテキストエディタを使っているなら, 可読性云々以前にその作業環境自体にそもそも問題がある. 今すぐ LaTeX の環境構築について学んで快適な作業環境の確保にリソースを振った方がよい.

## コマンドの作成例

### `\Set`

### `\integral`

## コマンド化する・しないの判断材料

### コマンド化しない

#### 対応概念が曖昧なとき

#### 単なる入力効率向上が目的のとき

### コマンド化するケース

#### 繰り返し登場する概念(NOT表記)があるとき

#### 1つのコマンドが異なる意味で使われているとき

#### 1つの記号の用途が2つ以上になったとき

#### 【特殊】可読性が増すケース

### 場合によるケース

#### 類似概念が存在するとき
