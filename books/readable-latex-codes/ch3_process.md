---
title: "良いコマンドを作るプロセス"
---

<!-- ## 良いコマンドを作るプロセス -->

### コマンドは外面から決める

`\concept` という名前のコマンドを定義しようとしているとしよう. 名前と対応概念以外は何も決まっていないとする.

コマンドを定義するとき, プリアンブルやstyファイルの中でどう中身を与えて定義するかという問題に意識が集中する人が多いと思う. コマンドの中身は100%自作するか, あるいはパッケージからパーツを借りて来るのか, それともまるっきりパッケージの関数を wrap するだけにするのか etc. それらは全て後回しにしよう. コマンドのインターフェースとしての役割を重視する立場からすると, それらははっきり言ってどうだっていい.

真っ先に考えるべきは, `\concept` コマンドが `document` 環境の中でどう呼び出されるべきかを決める作業だ. `document` 環境に公開するインターフェースの検討会議を開こう. 一度公開した後, オプション引数の追加やコマンド本体の微修正だけで長期間生き残るように, コマンドの対応概念を表現するのに必要十分な直観的な外面を用意しなければならない. ここをサボると後でもう一度考え直す羽目になる. その間に書いた半端な `\concept` コマンドの修正タスクも発生するはずなので時間を失うばかりだ.

具体的に確定させるべきは入出力の内容だ. 今は `\concept` が対応概念を持つと仮定しているので, 実は出力に関して決めることはない. 出力する記号を決める必要があるじゃないかと思うかもしれないが, 記号は仮置きで構わない. 対応概念の記号の影響範囲はこのコマンドだけだろうから, いつでもほぼゼロコストで変更できるからだ.

実質的課題は入力引数の決定だ. 様々な候補があるうち, どの引数を受け入れ, どの引数を受け入れないのか. 受け入れることにした変数のうち, どれを必須とするのか. 引数はどんな順番で並べるのか. 全て決める必要がある(決め方の指針は以下で詳しく述べる).

これらが決定して初めてコマンドの中身の実装作業に入る. コマンドの中身はすぐに完成させる必要はない(コンパイル等に支障がないなら). 部分的に仮置きの状態でその文書の続きを書いても全く問題ない. たとえば, もし `\concept[val1]{arg}[opt2=val2, opt3=val3]` のような形と決まったなら, `opt*`の名前だけ決めて, その他の値の出力値は仮置きして実装を先送りしてしまっても構わない.

`document` 環境で `\concept[v1]{x}[opt1=v2, opt3=v3]` と呼び出せるようになっているのなら, そのコマンドの役割は決定されたも同然だ. `\concept` コマンドがコミットすべきは `document` 環境における役割であって, 自身の定義の詳細ではない. その役割が決定されたのであれば, 残りの部分はいつか実装されれば問題ない. その完成タイミングはいつになっても構わない. 極端なことを言えば, 文書の大半の完成を見届けるまでコマンドの実装を渋っても構わない.

その意味では, コマンドは外面から決めるというより, コマンドは外面**だけ**決めるの方が実態に近い.

### 「自然な」引数の選び方

自然なコマンド引数を選ぶべきことなど百も承知なはずだろうが, 頭で分かっているだけでは足りない. コマンド引数の「自然さ」の判断基準が欲しい. どんなものが有り得るだろうか.
残念ながら, 一般には, そのコマンドの役割・目的に依存して無数の基準が有り得る.
したがって, その時々で恣意的な基準を選ぶことで自分の選択に対する自己批判をかわすことはいくらでもできる. これが多機能主義的なコマンドが産まれる背景の1つだろう.
しかし, 対応概念を持つコマンドに絞れば便利な基準がある. すなわち, **引数の候補が対応概念の中で自然な要素であるか**というテストを判断基準として使える. これによって, 過ぎた多機能化を予防できる.

たとえば, 導関数を対応概念に持つ `\derivative` というコマンドがあったとしよう. たとえば, $\frac{\partial^3 f}{\partial x_1 {\partial x_2}^2}$ という出力を行うものだ.
必須引数かオプションかは一旦置いておいて, このコマンドにとって自然な引数に, 微分可能関数 $f$, 微分を行う変数を指す ${x_1, x_2}$, そのオーダーを指す `{1, 2}` が含まれることに違和感はない. $f$ が1変数関数のときは $\partial$ ではなくて $d$ を使うのが慣習だから, この記号を切り替えるフラグ変数が含まれることにも異論はない. なぜなら, それらは微分概念とその標準的記法において自然に存在するもの達だからだ.

その導関数のある点$p$での評価値 $\left . \frac{\partial f}{\partial x_1}\right|_{p}$ を, (たとえば `\derivative{f}{x_1}[p]` のような形で)引数に含めるべきかは意見が分かれ得る. コマンド名の derivative は微分係数も含むからそれに相当する評価値をコマンドに取り込むのは自然という意見もあれば, 値の評価は微分操作とは別概念だから, `\eval{function}{at}` のようなコマンドを別に定義してそれに処理させるべきだという反対意見も有り得る.

他方で, $f$ の頭にハット $\hat{f}$ やチルダ $\widetilde{f}$ を乗せる選択肢を与える引数は明らかに不自然だ. 微分操作と何の関係もないからだ. $x$ の下付き添字をたとえば `\derivative{f}{x}[order={1,2}, subscript={1,2}]` のように指定する引数はやや不自然に思える. 関数の引数は必ずしも $f(x_1,\ldots,x_i,\ldots,x_k)$ のように書かれるとは限らないからだ.

このように, 明確な対応概念を持つコマンドであれば, 不自然な引数の大半をこの基準で明らかにできる. 不自然な引数は弾き, 意見の分かれそうな少数の引数についてだけ, 利便性・可読性・保守性を天秤にかけて採用するか個別に判断すればよい. パッケージとして公開するコマンドでない限り, 経験的に, 1つの文書で1つのコマンドに必要な引数の数はそう多くならないはずだ.

### 必須引数の決め方

引数のセットが決まったら, それらを必須引数とオプションに振り分けていくことになる. `\command{}{x}[y]` のように必須引数は空にならないように定義するのが基本だ. 空の `{}` は可読性を損なうので極力ない方がよい. 空になる用途が有り得るなら, その引数はオプションに逃がす.

:::message
必須引数は, コマンドの用途を意図通りのものに限定する役割がある一方で, 無計画に増やすと変更に弱くなる上に可読性を損ないやすい.
:::

もし `\command{}{x}` に積極的な意味があるなら(特に対応概念があるなら), そのパターンは1つのコマンドとして独立させることを検討した方がよいかもしれない.

たとえば, `\derivative{}{t}` $\frac{\partial}{\partial t}$ に時間微分作用素としての意味を与えているなら, `\timeDifferential` のようなコマンドを `\derivative` の特殊化として定義し, `\derivative{}{t}` と書くことを辞めた方がコードが解釈しやすくなる. もしくは, `\derivative{}{x}` の別名として, `\diffOperator{x}` などを定義してもよいかもしれない.

### 引数の並び順の決め方

引数の並び順も自然であるに越したことはない. 自然な基準は主に2つある.

- 引数の並び順の選択肢: 例 $\int_I f dx$
  - 数式として表示される順: `\integral[I]{f}{x}`
  - 読み上げ順: (integration of $f$ with respect to $x$ over $I$) `\integral{f}{x}[I]`

ソースコードと PDF の対応を重視するなら前者, ソースコードを自然言語に近付けることを重視するなら後者ということになるだろうか. 読み手が混乱しないなら, どちらを採用しても構わない. 両者を併用してもよい.

なお, 当然だが, 読み上げ順は何らかの対応概念の存在を前提としている. このような形で読み上げることができないコマンドは, 何らかの改善の余地がある場合が多い。

### オプションの実装方法

柔軟なオプション定義やkey-value形式のコマンド定義を可能にするパッケージがある. 執筆時点で代表的なものを挙げておく.

- keyval
- xkeyval
- xparse
- l3keys

パッケージの使用法の詳細は, 公式ドキュメントなどに譲る.

### コマンドとスニペットはペアで定義する

コマンドの外面を固めた後に必ずやるべきことがある. そのコマンドへのスニペットの定義だ.

大前提として, コマンドに対する入力支援の仕組みは必要不可欠だ. これがないと, 入力に時間がかかったり, それを嫌って不自然に短いコマンド名を付けるようになる. コマンドオプションの key が非直観的な略語だらけになり, 可読性を損なうことさえ有り得る. コマンド入力は面倒を感じないレベルまで高速化できる体制を必ず整えよう.

もし, そのような入力支援環境を整えられないテキストエディタを使っているなら, 可読性云々以前にその作業環境自体にそもそも問題がある. このような下流についての記事は今すぐ閉じて, LaTeX の環境構築について学ぶ等, 快適な作業環境の確保にリソースを振った方がよい.

やや蛇足. 上で, 1つのコマンドの過剰多機能化は保守性の観点から望ましくないと書いた. 同じことがスニペットによる入力支援の観点からも言える. たとえば, あるコマンドに10個のオプション引数があるとしよう. そのスニペットを打つたびに10個のオプション全てがサジェストされたらウザったくて仕方ないだろう. 大半のケースでは, せいぜい3~4個しかオプションは使わないのだから. こういうケースに出会ったら過剰機能を疑った方がよい.
