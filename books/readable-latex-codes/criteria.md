---
title: "コマンド化の判断基準"
---

何をコマンド化するかが決まれば, 前述のコマンド化のプロセスを進めること自体は難しくない. 難しいのは, コマンド化するのにふさわしい適切な単位を発見したり, その候補を実際にコマンド化するかどうか判断する部分だ. 後者の判断基準として, 以下は当然の内容だろう.

- コマンド化する・しないの基準
  - 可読性・保守性に寄与しないならコマンド化しない
  - 一方の犠牲なしに他方を改善できるならコマンド化する
  - 一方を犠牲にして他方を立てるケースは個別判断

これを判断基準として参照しつつ, コマンド化に馴染むコード・概念のパターン, 馴染まないパターンをそれぞれいくつか見ていく.

なお, 以下は重要度順等ではなく, 説明する上で都合がよい順.

## 肯定的基準

### 記号変更の可能性があり, 登場回数の多い概念があるとき → する

このような概念はコマンドという単位で管理することを考えた方がよい. 可読性が増すかは現状の記号次第だが, 記号の変更が起きてしまったときの保険として有用な場合が多い.

巻末の List of Symbols に載せるような記号はほとんど全てこれに該当するが, もう少し非自明な例もある.

たとえば, xxx空間をたくさん扱っていて, そのいずれかを指す大文字の記号 $X$, $Y$,...etc. が入り乱れているような状況を考えよう. このようなときは, 空間概念ごとに, たとえば `\BanachSp{X}`, `FrechetSp{V}` などのようにコマンドで仕切っておくとよい. 記号変更が起きたとき, たとえば Frechet 空間だけ `mathcal`に変えたくなったとき等にとても助かる.

### 1つの記号が用途によって異なる概念を指すとき → する

先のケースの特殊版に当たる.

同じ記号を共有する概念のうちのどれか1つに記号変更が生じた場合, `document` 環境での置換作業が非常に面倒になる. 記号用途の重なりが発生した時点で, 少なくともその片方は, 現時点の出現回数を問わずコマンド化した方がよい.

たとえば, 集合 $A$ の内部を `A^{\circ}` $A^{\circ}$, 関数の合成を `g \circ f` $g \circ f$ と書いているなら, 可読性への寄与を考慮して, 前者を `\interior{A}` として定義した方がよいだろう.
もちろん, 同時に後者を `g \composite f` などとコマンド化してもよい.

### 1つのコマンドの制限が別の対応概念を持つとき → する

典型的には, 用途の広いパッケージの関数を `document` 環境にベタ書きしているときに発生しやすい.

たとえば, derivative パッケージの `pdv` や diffcoeff パッケージの `\diffp` は, 導関数 $\frac{\partial f}{\partial x_1}$ , 微分作用素 $\frac{\partial}{\partial t}$, 接空間の基底 $\frac{\partial}{\partial x_i}$...etc., という風に複数概念を表現できてしまう.

このような場合は, パッケージ関数を特殊化・制限して, 対応概念ごとにコマンド化した方が可読性も増す上に Notation の管理もしやすくなる. たとえば, `\derivative`, `\diffOpt`, `\tanBasis` のようなコマンドを作るとよいだろう.

## 否定的基準

### 入力速度を上げたいだけのとき → しない

コマンド化せず, その内容を高速入力するスニペットを定義した方が良い.

可読性・保守性等への配慮がなく, 「動く」以外の価値を書き終わった瞬間的に失ったコードは負の遺産となる. そんなコードは存在しないに越したことはない. コードは書く時間よりも読まれる時間の方が長いので, 書く際の都合よりも読む際の都合を優先すべきだ.

### 合成コマンドが対応概念を持たないとき ➝ しない

理由は類型ごとに異なるが, 「コマンド化しない」が結論であることは確定である.
典型例を挙げておく.

#### 対応概念を持つコマンドを入力とする合成が対応概念を持たないとき → しない

基本的に, 対応概念を持つコマンドの対応概念を失わせるような合成は愚策である. 可読性や保守性に優れる単位に余計な要素をくっつけて, 台無しにするようなものだからである.

よって, 少なくともその合成方法は採用しない. 合成対象を整理して対応概念を持つように工夫するとよい. それが見つからないなら合成せずに, そのまま対応概念を持つコマンドとしてベタに書いておけばよい. 対応概念を持つコマンドの周辺は, 合成単位や概念操作が今後見抜かれて式が再整理される可能性がある. その際, 妙な単位でコマンド化されているよりは, 素直にベタ書きされている方が変更作業が軽いことが多い.

表記を圧縮したいだけなら下手にコマンド化せずに省略コマンドでその場しのぎをする方がよい. 半端なコマンドを広範囲に広げるリスクを取るよりずっとマシである.

#### ダミー記号を含む合成➝ しない

かなり強いアンチパターンである.

ダミー記号は, 変更される可能性は他と比べて高いし, 変更される箇所は気まぐれで法則性がないことが予想される. すなわち, コマンドによる記号管理と相性が悪い. なぜなら, 同管理法は, 変更がある場合は一括変更であること前提としていて, 局所変更は想定していないからだ[^1].

[^1]: 対応概念がある記号は変更されるなら基本的に一括変更される. そのため, コマンド管理と非常に相性がよい. ダミー記号は対応概念を持つ記号とは対照的な存在である.

仮にそのような合成コマンドが存在するときに, 当該ダミー記号の局所変更が実際に発生すると, ダミー記号を含む合成コマンドを解いて, その変更後の内容を手入力する作業が発生する. これなら最初からコマンド化されていないベタ書き状態の方がマシだ. ベタ書きされているなら, ダミー記号部分だけを新しい記号に置換するだけで済むからだ.

このように, この手の場当たり的記号をコマンド内に引き込むと, 変更時の手間が倍どころではなく増える. よって, 完全に締め出した方がよい. ダミー記号を伴ったパターンを頻出するなら, スニペットを整備してそのパターンを高速入力できるようにすれば足りる.

合成の目的が, 局所的な表記の圧縮が目的なら省略コマンドで処理した方がよい. 記号自身が元々意味を持たないことと一時的用途であることを考慮すると, それが最も自然な対応策である. なお, ダミー記号はできれば省略コマンドにさえ含めない方がよい. `\xxAbbreviation{x}{\~f}` のようにコマンド定義には含めず引数の値として与える方が安全だ.

## Misc

### 特定の記法へのショートカットが欲しいとき → ?

目的のコードが対応概念を持つなら, 単コマンドや記法コマンドとしてコマンド化を試みればよい. 対応概念を持たない場合, シンプルなダミー記号の出力が目的ならコマンド化してよい. 対応概念を持たない合成は上で述べたように推奨されない.

以上に当てはまらない類型はレアケースだろうが,

### コマンドに付ける添字管理がしたいとき → ?

ここで言う「添字」は, 数字に当たるものだけでなく, 記号も含む. たとえば, $P_X$ の $X$ も添字として扱う.

上で, `\derivative` コマンドの引数として, `\derivative{f}{x}[order={1,2}, subscript={1,2}]` のような添字管理オプションは自然ではないと書いた. これは個別例であり, 添字管理するコマンドやオプション全般についてそう言っているわけではない.

その標準的記法に添字が込められていると見なせる概念は多くある. その場合は, 対応概念のコマンドに添字管理用のオプションを与えることは自然だろう.

たとえばノルムや内積, 距離などの特定の空間に付随する計量関数は, 本来その空間を明示して `\norm{f}_X` などと書くべきだ. 文脈から明らかな場合は省略して単に `\norm{f}` と書く慣習があるに過ぎない. この省略内容を明示するオプションはむしろある方が自然だろう.

`\norm{f}_X` や `\norm{f}_1` のような書き方しかしないと決まっているならコマンド化の必要性は薄れるが, ノルム空間に対する Notation を `\NormSp{X}` のようなコマンドで管理している場合は添字管理をコマンドで行った方がよい. `\norm{f}_{\NormSp{X}}` は明らかに冗長だし, braces `{}` の連続も目に優しくない. 代わりに, `\norm{f}[space=X]` などと書けるようにするとよいだろう.

類似例として, 写像等が誘導・生成する概念はこのような添字管理方法が自然な場合が多い. たとえば, 包含写像 $i: W \to X$ が引き起こす相対位相 $\mathcal{O}_W$, 確率変数 $X$ が引き起こす確率測度($X$ の分布) $P_X$ などがそれに当たる.
